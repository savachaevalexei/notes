# Навигация #

## Основы ##

|
[Типы данных](#типы-данных--↑) | 
[Арифметические операции](#арифметические-операции--↑) |
[Операторы сравнения](#операторы-сравнения--↑) |
[Логические операторы](#логические-операторы--↑) |
[Математические функции](#математические-функции--↑) |
[Стандартные функции](#стандартные-функции--↑) |
[Срезы](#срезы--↑) |
[Основные методы строк](#основные-методы-строк--↑) |
[Списки](#списки--↑) |
[Методы списков](#методы-списков--↑) |
[Вложенные списки](#вложенные-списки--↑) |
[Условынй оператор if](#условный-оператор-if--↑) |
[Тернарный оператор](#тернарный-оператор--↑) |
[Конструкция match/case](#конструкция-matchcase--↑) |
[Цикл while](#цикл-while--↑) |
[Цикл for](#цикл-for--↑) |
[Итерируемые объекты](#итерируемые-объекты--↑) |
[Генераторы списков](#генераторы-списков--↑) |
[Словари](#словари--↑) |
[Методы словаря](#методы-словаря--↑) |
[Кортежи](#кортежи--↑) |
[Множества](#множества--↑) |
[Операции над множествами](#операции-над-множествами--↑) |
[Генераторы множеств и словарей](#генераторы-множеств-и-словарей--↑) |
[Функции](#функции--↑) |
[Рекурсивные функции](#рекурсивные-функции--↑) |
[Lambda функции](#lambda-функции--↑) |
[Замыкания](#замыкания--↑) |
[Декораторы функций](#декораторы-функций--↑) |
[map](#map--↑) |
[filter](#filter--↑) |
[zip](#zip--↑) |
[sort() и sorted()](#sort-и-sorted--↑) |
[isinstance()](#isinstance--↑) |
[all() и any()](#all-и-any-↑) |
[Системы счисления](#системы-счисления--↑) |
[Битовые операции](#битовые-операции--↑) |

## ООП ##

|
[Концепция ООП](#концепция-ооп--↑) |
[Атрибуты](#атрибуты--↑) |
[Методы](#методы--↑) |
[Инициализатор и финализатор](#инициализатор-и-финализатор--↑) |
[Метод new](#метод-new--↑) | 
[classmethod и staticmethod](#classmethod-и-staticmethod--↑) |

# Типы данных # [&#8593;](#навигация)

`int` - целочисленный тип

`float` - вещественный (дробный) тип

`complex` - комплексный тип

`true - false` - логический (булевый) тип

`str` - строковый тип (неизменяемый тип данных)

# Арифметические операции # [&#8593;](#навигация)

<table>
    <tr>
        <th>Оператор</th>
        <th>Описание</th>
        <th>Приоритет</th>
    </tr>
    <tr>
        <td>+</td>
        <td>сложение</td>
         <td>2</td>
    </tr>
    <tr>
        <td>-</td>
        <td>вычитание</td>
         <td>2</td>
    </tr>
    <tr>
        <td>*</td>
        <td>умножение</td>
         <td>3</td>
    </tr>
    <tr>
        <td>/</td>
        <td>деление</td>
         <td>3</td>
    </tr>
    <tr>
        <td>//</td>
        <td>деление с округлением к наименьшему целому</td>
         <td>3</td>
    </tr>
    <tr>
        <td>%</td>
        <td>остаток от деления</td>
         <td>3</td>
    </tr>
    <tr>
        <td>**</td>
        <td>возведение в степень</td>
         <td>4</td>
    </tr>
</table>

# Операторы сравнения # [&#8593;](#навигация)

<table>
    <tr>
        <th>Оператор</th>
        <th>Функция</th>
     </tr>
    <tr>
        <th><</th>
        <th>сравнение на меньше</th>
     </tr>
         <tr>
        <th>></th>
        <th>сравнение на больше</th>
     </tr>
         <tr>
        <th><=</th>
        <th>сравнение на меньше или равно</th>
     </tr>
         <tr>
        <th>>=</th>
        <th>сравнение на больше или равно</th>
     </tr>
         <tr>
        <th>==</th>
        <th>сравнение на равенство</th>
     </tr>
         <tr>
        <th>!=</th>
        <th>сравнение на неравенство</th>
     </tr>
</table>   

# Логические операторы # [&#8593;](#навигация)

<table>
    <tr>
        <th>Оператор</th>
        <th>Функция</th>
        <th>Приоритет</th>
     </tr>
     <tr>
        <th>not</th>
        <th>not x - если x ложно, то возвращается True, иначе False</th>
        <th>1</th>
     </tr>
     <tr>
        <th>and</th>
        <th>x and y - если x ложно, то возвращается x, иначе у</th>
        <th>2</th>
     </tr>
     <tr>
        <th>or</th>
        <th>x or y - если x ложно, то возвращается у, иначе x</th>
        <th>3</th>
     </tr>
</table>


# Математические функции # [&#8593;](#навигация)

`abs()`- модуль числа

`min()` - наименьше значение из переданных в аргумент функции Например, `min(6,2,3)` выдаст результат `2`

`max()` - наибольшее значение из переданных в аргумент функции Например, `max(6,2,3)` выдаст результат `6`

`pow()` - возведение числа в степень. Например, `pow(6,2)` выдаст результат `36`

`round()` - округление к ближайшему целому. Вторым аргументом в функцию можно передать точность округления (1 - до десятых, 2 - до сотых, 3 - до тысячных и т.д.). Например, `round(10.845575,3)` выдаст результат `10.846`.

# Стандартные функции # [&#8593;](#навигация)

`print()` - вывести данные на экран. Например, `print("Hello")`, выведет `Hello`.

`print(f"")` - f-строка. Использууется для вывода текста и переменных в одной функции print.
```
>>> name = "Ivan"
>>> print(f"Hello {name}!")
Hello Ivan!
```

`input()` - ввод данных в программу с клавиатуры.
```
name = input("Enter you name")
print(f"Hello, {name}!")
```

`type()` - позволяет получить тип данных, указанных в аргументе функции. Данные введеные в программу с использованием функции input() всегда имеют `<class 'str'>`.
```
>>> a = 1
>>> b = input()
>>> print(type(a))
<class 'int'>
>>> print(type(b))
<class 'str'>
```

`int()` - преобразовать информацию в целое число. Пример использования в связке с функцией input():
```
>>> number = int(input())
123
>>> type(number)
<class 'int'>
```

`float()` - преобразовать информацию в вещественное число. Используется аналогично с функцией `int()`.

`len()` - узнать длину строки.

```
>>> a = "text"
>>> b = [1,2,3]
>>> len(a)
4
>>> len(b)
3
```

`in` - проверить входит ли строка в другую строку.

```
>>> a = "abcd"
>>> b = "ab"
>>> a in b
False
>>> b in a
True
```

`ord()` - определение кода символа.

```
>>> ord('K')
75
>>> ord('k')
107
```

# Срезы # [&#8593;](#навигация)

Каждый элемент строки или массива имеет свой индекс. Нумерация индексов начинается с 0 (нуля). Для обращения к нужному элементу строки или списка, необходимо в квадратных скобках указать номер его индекса.

```
>>> a = "Hello"
>>> a[0]
'H'
>>> a[1]
'e'
```
Существует дополнительная индексация - отрицательная. Можно в квадратных скобках указать значение: 
* -1 для обращения к последнему элементу;
* -2 для обращения к предпоследнему элементу.

```
>>> a = [1, 2, 3]
>>> a[-1]
3
>>> a[-2]
2
```


`переменная[start:stop]` - срез строки, где `переменная` - имя строкойвой переменной, `start` - индекс с которого начинается срез, `stop` - индекс перед которым срез закончится (элемент с индексом `stop` не входит в срез) .

```
>>> a = [1,2,3,4,5]
>>> a[1:3]
[2, 3]
```
Если не указать элемент до которого делается срез, то срез будет сделан до конца строки.

```
>>> a = "Hello"
>>> a[1:]
'ello'
```
Таким же образом можно не указывать и начальный элемент среза, тогда срез будет сделан от элемента с индексом ноль.

```
>>> a = "Hello"
>>> a[:3]
'Hel'
```

Для того чтобы указать шаг среза, необходимо использовать конструкцию типа `переменная[start:stop:step]`

```
>>> a = "hello python"
>>> a[2:10:2]
'lopt'
```

Используя срезы, можно получить разворот (последовательность элементов в обратном порядке).

```
>>> a = "hello python"
>>> a[::-1]
'nohtyp olleh'
```

Используя срез можно получить копию массива.

```
>>> a
[1, 2, 4, 5, 6]
>>> b = a[:]
>>> b
[1, 2, 4, 5, 6]
```

# Основные методы строк # [&#8593;](#навигация)

Чтобы вызвать какой либо метод для работы со строками, неоходимо использовать конструкцию типа `строка.метод()`. 

`.upper()` - перевести все символы в верхний регистр.

`.lower()` - перевести все символы в нижний регистр.

`.swapcase()` - поменять регистр каждого символа на противоположный.

`.capitalize()` - сделать первый символ в верхнем регистре, а остальные в нижнем.

`.count(sub[,start[,end]])` - число повторений подстроки в строке, где параметр `start` - индекс с которого начинается поиск, параметр `end` - индекс на котором заканчивается поиск. Параметры необязательны.

```
>>> msg = "abrakadabra"
>>> msg.count("ra")
2
```

`.find()` - возвращает индекс первого найденого вхождения подстроки в строку. Можно задать индексы элементов от которого и до которого будет произведен поиск.

```
>>> msg = "abrakadabra"
>>> msg.find("br")
1
```

`.replace("x",'y')` - заменить все буквы х на у.

`.isalpha()` - возвращает true, если строка полностью состоит из букв.

`.isdigit()` - возвращает true, если строка полностью состоит из цифр.

`.split()` - возвращает строку, разбитую по маркеру.

```
>>> name = "Алексей Иванович Иванов"
>>> name.split(" ")
['Алексей', 'Иванович', 'Иванов']
```

`" ".join()` - объеденить подстроки в строку.

```
>>> name = "Алексей Иванович Иванов"
>>> n = name.split(" ")
>>> " ".join(n)
'Алексей Иванович Иванов'
```

# Списки # [&#8593;](#навигация)

Список - изменяемый тип данных. Чтобы перезаписать значение в списке, необходимо обратится по индексу к нужному элементу и присвоить ему новое значение.

Элементом списка может быть любой тип данных языка python.

#### `len()` - число элементов в списке.

`min() max()` - получить минимальное или максимальное значение.

`sum()` - сумма элементов списка.

`sorted()` - создает новый отсортированный список.

`+` - соединение двух списков в один.

`*` - дублирование списка.

#### `in` - проверка вхождения элемента в список. На выходе получаем true или false.

#### `del` - удаление элемента списка.


# Методы списков # [&#8593;](#навигация)

`.append()` - добавить элемент в конец списка.

```
>>> a = [1, 2, 3, 4, 5]
>>> a.append(6)
>>> a
[1, 2, 3, 4, 5, 6]
```

`.insert(3, 100)` - вставить элемет со значением 100 на позицию со значениемм 3.

```
>>> a.insert(3,100)
>>> a
[1, 2, 3, 100, 4, 5, 6]
```

`.remove(3)` - удалит из списка, первый попавшийся элемент со значением 3.

```
>>> a.remove(3)
>>> a
[1, 2, 100, 4, 5, 6]
```

`a.pop(2)` - удалит из списка элемент с индексом 2 и вернет значение удаляемого объекта.

```
>>> a.pop(2)
100
>>> a
[1, 2, 4, 5, 6]
```

`.clear()` - полностью очистить список.

`.copy()` - копировать список. Так же копировать список можно через срез `b = a[:]`

`.count(1)` - посчитать сколько раз встречается элемент со значением 1.

```
>>> a
[1, 2, 1, 4, 5, 6]
>>> a.count(1)
2
```

`.index(1)` - возвращает индекс элемента со значением 1. Вторым аргументом можно передать стартовый индекс для поиска. Например, `.index(1,2)`.

```
>>> a
[1, 2, 1, 4, 5, 6]
>>> a.index(1)
0
>>> a.index(1,2)
2
```

`.reverse()` - развернуть список. Также можно развернуть через срез `a[::-1]`

```
>>> a
[1, 2, 1, 4, 5, 6]
>>> a.reverse()
>>> a
[6, 5, 4, 1, 2, 1]
```

`.sort()` - сортирует текущий список.

```
>>> a.sort()
>>> a
[1, 1, 2, 4, 5, 6]
```

# Вложенные списки # [&#8593;](#навигация)

Элементом списка может быть другой список.

```
>>> a = [[1,2,3], [4,5,6], [7,8,9]]
>>> a
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

Чтобы обратится к конкретному элементу вложенного списка, нужно указать индекс вложенного списка и индекс его элемента.

```
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> a[1][2]
6
```


# Условный оператор if # [&#8593;](#навигация)

Структура услоного оператора if-else:

```
if [условие]:
    [действие 1]
    [действие 2]
    ...
    [действие n]
else
    [действие 1]
    [действие 2]
    ...
    [действие n]
```

Структура вложенного оператора:

```
if [условие]:
    if [условие]:
        [действие 1]
        [действие 2]
        ...
        [действие n]
    else:
        [действие 1]
        [действие 2]
        ...
        [действие n]
else:
    [действие 1]
    [действие 2]
    ...
    [действие n]
```

Конструкция условия с множественным выбором:

```
if [условие]:
    [действие]
elif [условие]:
    [действие]
elif [условие]:
    [действие]
elif [условие]:
    [действие]
else [условие]:
    [действие]
```

# Тернарный оператор # [&#8593;](#навигация)

Тернарный оператор имеет структуру: `[значение 1] if [условие] else [значение 2]`. Результат работы тернарного оператора необходимо сохранять в переменную.

На осонове тернарного оператора делаются [генераторы списков](#генераторы-списков--↑).
```
>>> a = 12
>>> b = 7
>>> res = a if a > b else b
>>> res
12
```

# Цикл while # [&#8593;](#навигация)

Структура цикла:

```
while [условие]:
    [действие]
```

`break` - досрочное завершение цикла.

`continue` - пропуск одной итерации цикла.

# Цикл for # [&#8593;](#навигация)

Структура цикла:

```
for [переменная] in [итерируемый объект]:
    [действие]
```

`range(start, stop, step)` - генерирует список с элементами от start до stop с шагом step

```
>>> list(range(0,5,1))
[0, 1, 2, 3, 4]
```

`range(start, stop)`

```
>>> list(range(0,5))
[0, 1, 2, 3, 4]
```
`range(stop)`

```
>>> list(range(5))
[0, 1, 2, 3, 4]
```

Если внутри цикла содержится еще один цикл, то он называется вложенным. Уровень вложенности не ограничен.

# Итерируемые объекты # [&#8593;](#навигация)

Строки и списки - итерируеммые объекты. 

`iter()` - создать итератор.

```
>>> a = [1, 2, 3, 4, 5]
>>> b = iter(a)
>>> b
<list_iterator object at 0x7fe89160cdc0>
```

`next()` - вывести следующий итерируемый объект. Позволяет один раз пройти по всем элементам объекта.

```
>>> next(b)
1
>>> next(b)
2
```

# Генераторы списков # [&#8593;](#навигация)

Структура гененратора:
`[способ формирования значения] for [переменная] in [итерируемый объект]`

Например, генератор квадратов чисел из заданноого диапазона:

```
>>> a = [x ** 2 for x in range(6)]
>>> a
[0, 1, 4, 9, 16, 25]
```

Генератор с условием, который выводит только четные числа из заданного диапазона:

```
>>> a = [x for x in range(-5, 5) if x % 2 == 0]
>>> a
[-4, -2, 0, 2, 4]
```

Можно создавать более сложные структуры генератора, используя вложенные операторы цикла:

```
[способ формирования значение]
    for [переменная 1] in [итерируемый объект] if [условие]
    for [переменная 2] in [итерируемый объект] if [условие]
    ...
    for [переменная n] in [итерируемый объект] if [условие]
```

```
>>> a = [(i,j) 
        for i in range(3) 
        for j in range(3)
        ]
>>> a
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
```

# Словари # [&#8593;](#навигация)

Структура словаря: `{key_1 : value_1, key_2 : value_2, ... , key_n : value_n}`

```
>>> a = {"house" : "дом", "road" : "дорога"}
>>> a
{'house': 'дом', 'road': 'дорога'}
```

Т.к. словарь представляет из себя сочетание ключ-значение, то чтобы получить значение, необходимо обратится к ключу, по аналогии с тем, как получали значение по индексу из списка.

```
>>> a["house"]
'дом'
```

Одному ключу в словаре соответствует одно конкретное значениие. 

Чтобы преобразовать вложенный список в словарь, можно использовать функцию `dict()`:

```
>>> lst = [[1,"a"],[2,"b"],[3,"c"]]
>>> dict(lst)
{1: 'a', 2: 'b', 3: 'c'}
```

Функции [len](#len---число-элементов-в-списке), [in](#in---проверка-вхождения-элемента-в-список-на-выходе-получаем-true-или-false), [del](#del---удаление-элемента-списка) выполняют аналогичные функции, что и описанные в разделе [списки](#списки--↑)

# Методы словаря # [&#8593;](#навигация)

`.fromkeys(lst, "value")` - добавить в словарь ключи из списка и присвоить им значениие `value`.

```
>>> d = dict.fromkeys(lst, "value")
>>> d
{'1': 'value', '2': 'value', '3': 'value'}
```

`.copy()` - создать копию словаря

```
>>> d = dict.fromkeys(lst, "value")
>>> dd = d.copy()
>>> dd
{'1': 'value', '2': 'value', '3': 'value'}
```

`.get(key, False)`  - получить значения по ключу `key` или вывести `False`, если такого ключа нет. 

```
{1: 'value', 2: 'value', 3: 'value'}
>>> d.get(2)
'value'

>>> d.get(123, False)
False
```

`.setdefault(key, default)` - возвращает значение по ключу `key`, а также присваевает знаечение `default` если такого ключа нет.

```
>>> d.setdefault(1, "hello")
'value'

>>> d.setdefault(12, "hello")
'hello'
>>> d
{1: 'value', 2: 'value', 3: 'value', 12: 'hello'}
```

`.pop(key, False)` - удалить ключ из словаря. Если такого ключа нет, вернет `False`.

`.popitem()` - удаляет случайный ключ.

`.keys` - возвращает список ключей.

# Кортежи # [&#8593;](#навигация)

Кортеж - упорядоченная, но неизменяемая коллекция произвольных данных.

`a = (1,2,3)` - создать кортеж из 3 элементов.

# Множества # [&#8593;](#навигация)

Множества - неупорядоченная коллекция УНИКАЛЬНЫХ элементов. Множество может содержать в себе только неизменяемые типы данных (числа, булевы значения, строки, кортежи). Нельзя использовать при создании множества: списки, словари и другие множества.

`a = {1, 2, 3}` - создание множества.

`set()` - создать пустое множество.

`.add(value)` - добавить во множество элемент со значением `value`.

`.update()` - добавить сразу несколько элементов во множество. В качества аргумента передается любой итерируемый объект (списко, кортеж).

`.discard(value)` - удалить из множества элемент со значением `value`.

`.remove(value)` - удалить из множества элемент со значением `value`, если такого элемента нет - возратит ошибку.

# Операции над множествами # [&#8593;](#навигация)

Допустим, имеются два множества:

```
>>> setA = {1, 2, 3, 4}
>>> setB = {3, 4, 5, 6, 7}
```

`setA & setB` - пересечениие (элементы, общие для обоих множеств) двух множеств. Пересечение можно получить с помощью метода `setA.intersection(setB)`.

```
>>> setA & setB
{3, 4}
```

`setA | setB` - объединение двух множеств. Аналогичную операцию можно записать с использованием метода `setA.union(setB)`.

```
>>> setA | setB
{1, 2, 3, 4, 5, 6, 7}
```

`setA - setB` - вычитание множеств. Результатом будет множество элементов, которые не входят в вычитаемое множество.

```
>>> setA - setB
{1, 2}
>>> setB - setA
{5, 6, 7}
```

`setA ^ setB` - симметричная разность. На выходе имеем элементы уникальные для обоих множеств.

```
>>> setA ^ setB
{1, 2, 5, 6, 7}
```

`setA == setB` - полчуаем `True`, если количство элементов и их значения совпадают у обоих множеств.

`setA != setB` - сравнение на неравенство.

`setB < setA` - получаем `True`, если `setB` включается в `setA`.

# Генераторы множеств и словарей # [&#8593;](#навигация)

`{[способ формирования значения] for [счет] in [итерируемый объект] if [условие]}` - генератор множества.

`{[способ формирования значения : способ формирования значения] for [счет] in [итерируемый объект] if [условие]}` - генератор словаря.

# Функции # [&#8593;](#навигация)

Структура функции:

```
def <name> (arguments):
    operator 1
    operator 2
    ...
    operator N
```

Имя функции должно соответствовать тому, что она делает (глагол).

```
def send_mail():
    text="text email"
    print(text)
```

Чтобы выполнить работу функции, ее необходимо вызвать. Вызов функции может быть осуществлен, только после объявлении самой функции.

```
>>> send_mail()
text email
```

Функции в качестве параметра можно передавать аргумент при вызове функции.

```
def send_mail(from_name):
    text=f"text email from {from_name}"
    print(text)

>>> send_mail("alex")
text email from alex
```

При вызове функции, можно явно указывать, какое значение соответствует какому параметру. 
```
def send_mail(name, age):
    text=f"Привет! Меня зовут {name}. Мне {age} лет."
    print(text)

>>> send_mail(age=100, name="Alex")
Привет! Меня зовут Alex. Мне 100 лет.
```

`return` - используется для возвращения результата работы функции.

```
def get_square(x):
    res = x**2
    return res

>>> get_square(2)
4
```

`*args` - параметр функции, который позволяет получить любое количество аргументов.

`**kwargs` - передать все именованные аргументы в параметр функции.

# Рекурсивные функции # [&#8593;](#навигация)

Рекурсивная функция - функция которая вызывает саму себя.

```
def recusive(count)
    print(count)
    if count < 4:
        recursive(count + 1)

recursive(1)
```

# Lambda функции # [&#8593;](#навигация)

Лямбда функция - анонимная функция. Она не имеет названия. Автоматически возвращает результат.

```
>>> s = lambda a, b : a + b
>>> s(1,2)
3
```

# Замыкания # [&#8593;](#навигация)

```
>>> def say_name(name):
...     def say_goodbay():
...         print(f"Dont say me goodbay {name} !")
...     say_goodbay()
... 
>>> 
>>> say_name("alex")
Dont say me goodbay alex !
```

# Декораторы функций # [&#8593;](#навигация)

Декораторы в Python — это функции, которые принимают другую функцию в качестве аргумента, добавляют к ней некоторую дополнительную функциональность и возвращают функцию с измененным поведением.

# map # [&#8593;](#навигация)

Функция map применяет функцию к каждому элементу последовательности и возвращает итератор с результатами.

Например, преобразовать список состоящий из строк, можно преобразовать в списко состоящий из цифр.

```
b = map(int,[1, 2, 3, 4, 5])
```

# filter # [&#8593;](#навигация)

`filter(func,*iterables)` -  фильтрация элементов итерируемого объекта.

Например, чтобы вывести все четные числа из списка:

```
>>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> b = filter(lambda x : x % 2 == 0, a)
>>> 
>>> for x in b:
...     print(x)
... 
2
4
6
8
```

Результат работы `b = filter(lambda x : x % 2 == 0, a)` можно записать в любую коллекцию (Список, кортеж и т.д) - `lst = list(b)`.


# zip # [&#8593;](#навигация)

`zip(iter1[, iter2 [,iter3]...])` - структура функции.

Функция `zip` позволяет последовательно пройти по сразу нескольким итерируемым объектам.

```
>>> b = ["Ivan", "Alex", "Vova"]
>>> a = [1, 2, 3, 4, 5]
>>> z = zip(a, b)
>>> print(next(z))
(1, 'Ivan')
>>> print(next(z))
(2, 'Alex')
>>> print(next(z))
(3, 'Vova')
```

`next()` - вызывает следующий элемент итерируемого объекта.

# sort() и sorted() # [&#8593;](#навигация)

`list.sort()` - метод для сортировки элементов списка. Применяется только для сортировки изменяемых объектов (списки).

```
>>> a = [0, -2, 3, -5, 2]
>>> a.sort()
>>> a
[-5, -2, 0, 2, 3]
```

`sorted()` - функция для сортировки итерируемых объектов. Возвращает новый список, отсортированный по возрастанию.

Например, при работе с кортежем:

```
>>> b = ("asdg", "sets", "wefg")
>>> sorted(b)
['asdg', 'sets', 'wefg']
```

Или при работе со строкой:

```
>>> sorted("python")
['h', 'n', 'o', 'p', 't', 'y']
```

Если необходима сортировка по убыванию, нужно вторым аргументом передать `reverse = True`:

```
>>> sorted ([1, 0, -5, 4, 2, -3], reverse = True)
[4, 2, 1, 0, -3, -5]
```

# isinstance() # [&#8593;](#навигация)

`isinstance(обьект, тип данных)` позволяет проверить соответствует ли объект типу данных.

```
>>> a = 5
>>> isinstance(a, int)
True
>>> isinstance(a, str)
False
```

# all() и any()# [&#8593;](#навигация)

`all()` - если все элементы объекта не имеют пустых значений (с точки зрения bool), вернет True.

```
>>> all(b)
True
>>> a = [True, True]
>>> all(a)
True
>>> b = [True, False]
>>> all(b)
False
```

`any()` - возвращает True, если хоть один элемент  True.

```
>>> a = [False, False]
>>> b = [True, False]
>>> any(a)
False
>>> any(b)
True
```

# Системы счисления # [&#8593;](#навигация)

Чтобы присвоить переменной значеение в двоичной форме, необходимо перед значением поставить `0b`:

```
>>> b = 0b1111
>>> b
15
```

`bin(10)` - для перевода из десятичной формы в двоичную форму.

```
>>> bin(10)
'0b1010'
```

Чтобы присвоить переменной значение в шестнадцатеричной форме, перед значением нужно поставить `0x`:

```
>>> b = 0xde
>>> b
222
```

`hex(222)` - для перевода из десятичной в шестнадцатеричную форму:

```
>>> hex(222)
'0xde'
```

Чтобы присвоить переменной значение в восьмеричной форме, перед значением нужно поставить `0o`:

```
>>> b = 0o54
>>> b
44
```

`oct(44)` - для перевода из десятичной в восьмееричную систему.

```
>>> oct(44)
'0o54'
```

# Битовые операции # [&#8593;](#навигация)

`~` - битовая операция НЕ.

`&` - битовая операция И.

`|` - битовая операция ИЛИ.

 `^` - битовая операция ИСКЛЮЧАЮЩЕЕ ИЛИ.

# Конструкция match/case # [&#8593;](#навигация)

Конструкция служит для проверки на соответствия и имеет вид:

```
cmd = "top"

match cmd:
    case "top":
        print("top")
    case "down"
        print("down")
    case _:
        print("другое значение)
```

# Концепция ООП # [&#8593;](#навигация)

Чтобы представить однотипные данные в программе как единое целое, используются классы. Класс можно воспринимать как шаблон по которому будут формироваться данные.

У класса есть атрибуты (переменные внутри класса).

Обьекты класса - данные относящиеся к классу.

Например, рассмотрим базу учета кошек. Тогда, кошка - это класс, который имеет атрибуты порода, имя, возраст. А объектом класса будет конкретный экземпляр, например сиамский кот Вася которому 3 года.

Т.е. обьект класса создан по образу и подобию класса, но имеет разные данные атрибутов.

Метод класса  - набор функций, определенных для работы с классом и его объектами.

В соответствии со стандартом PEP8, имя класса задается с заглавной буквы.

Реализуем класс для хранения координат точек на плоскости:

```
class Point:
    color = 'red'
    circle = 2

```

Чтобы реализовать объекты класса (экземпляры) нужно обратиться к классу:

```
a = Point()
b = Point()
```

При этом, такие экземпляры класса не имеют собственных атрибутов, а берут их у родительского классса.

Чтобы убедится, что переменные `a` и `b` объекты класса поинт:

```
print(type(a))
print(type(b))

<class '__main__.Point'>
<class '__main__.Point'>
```

# Атрибуты # [&#8593;](#навигация)

Чтобы явно задать параметр атрибута для экземпляра класса, небоходимо:

```
a.color = 'green'
print(a.color)
print(b.color)

green
red
```

Получается, что экземпляр класса `a` берет значение атрибута `color` из собственного пространства имен, а экземпляр класса `b` - из родительского.

Атрибуты класса можно добавлсять динамически (т.е. в ходе выполнения программы). Например, создадим свойство `type_pt` со значеннием `disc`. Это свойство унаследуют и другие экземпляры класса (`a и b`)

```
>>> Point.type_pt = 'disc'
```

Также добавить новый атрибут классу можно используя функцию `setattr`, которая имеет следующую структуру `setattr(class_name, 'atribut_name', 'atribut_value')`. Например

```
setattr(Point, 'prop', 1)
```

Чтобы удалить из класса какой-либо атрибут, необходимо использовать функцию `del`:

```
>>> del Point.prop
```

Или, удаление можно произвести с функцией

```
delattr(Point, 'prop')
```

Чтобы проверить, есть ли в том или ином пространстве имен какой-то атрибут, нужно:

```
>>> hasattr(Point, 'prop')
False
```

Чтобы добавить классу описание, необходмио после объявления класса в двойных ковычках указать нужную информацию:

```
class Point:
    "Класс для предоставления точек на плоскости"
    color = 'red'
    circle = 2

>>> Point.__doc__
'Класс для предоставления точек на плоскости'
```

`__doc__` - содержит строку с описанием класса.

`__dict__` -  содержит набор атрибутов экземпляра класса.

Чтобы получить значение нужного атрибута нужно:

```
>>> getattr(Point,'color')
'red'
```

# Методы # [&#8593;](#навигация)

Именя метода должно задаваться в виде глагола, характеризующим предназначение метода.

Метод класса добавляется в тело класса:

```
class Point:
    color = 'red'
    circle = 2

    def set_cords():
        print("Call set_cords")
```

Чтобы вызвать метод класса нужно:

```
>>> Point.set_cords()

Call set_cords
```

`self` - необходим, чтобы интерпретатор python автоматически подставлял в качестве первого аргумента ссылку на экземпляр класса.

Используя `self` мы можем получить доступ к методам класса из экземпляра класса.

```
class Point:
    color = 'red'
    circle = 2

    def set_cords(self):
        print(f"Call set_cords {str(self)}")

pt = Point()

pt.set_cords()
```

В резульате работы программы, получим результат работы метода `set_cords` (сообщение `Call set_cords`), а также адрес экземпляра класса для которого был вызван этот метод (`<__main__.Point object at 0x7fbca2ee4410`):

```
Call set_cords <__main__.Point object at 0x7fbca2ee4410>
```

Используя методы класса можно добавлять локальные свойства экземплярам класса. Для этого метод должен принимать необходимые параметры. 

Например, создадим 2 экземпляра класса `pt и pt2` и используя метод `set_cords` добавим этим экземплярам атрибуты с конкретными значениями:

```
class Point:
    color = 'red'
    circle = 2

    def set_cords(self, x, y):
        self.x = x
        self.y = y

pt = Point()
pt2 = Point()

pt.set_cords(1, 2)
pt2.set_cords(4, 6)

print(pt.__dict__)
print(pt2.__dict__)

{'x': 1, 'y': 2}
{'x': 4, 'y': 6}
```

# Инициализатор и финализатор # [&#8593;](#навигация)

В каждом классе языка python есть магические методы.

`__init__(self)` - вызывается сразу после создания экземпляра класса.

`__del__(self)` - финализатор класса. Вызывается перед удалением класса.

Допустим имеется класс и методы внутри него:

```
class Point:
    color = 'red'
    circle = 2

    def set_cords(self, x, y):
        self.x = x
        self.y = y

    def get_cords(self):
        return self.x, self.y
```

Добавим магический метод `__init__` со значениями для x и y:

```
class Point:
    color = 'red'
    circle = 2

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def set_cords(self, x, y):
        self.x = x
        self.y = y

    def get_cords(self):
        return self.x, self.y
    

pt = Point(1,2)

print(pt.__dict__)

{'x': 1, 'y': 2}
```

Также можно сделать значения `x и y` по умолчанию, для этого их нуно явно задать:

```
def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
```

Пока на объект ведет хоть одна внешняя ссылка - объект нужный. Если ссылок нет - встроенный сборщик мусора в python удалит ненужный объект. Непосредственно перед удалением будет вызван финализатор.

# Метод new # [&#8593;](#навигация)

`__new__()` - вызывается перед созданием объекта класса.

Явно использование данного магическиего метода, необходимо при использовании паттерна проектирования Singleton.

# classmethod и staticmethod # [&#8593;](#навигация)

До этого момента методы объявлялись как функции внутри класса:

```
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def get_cords(self):
        return self.x, self.y
    

v = Vector(1, 2)
res = v.get_cords()
print(res)

(1, 2)
```

Добавим в метод 2 атрибута:

```
class Vector:
    MIN_CORD = 0;
    MAX_CORD = 100;
```

Метод класса работает исключительно с атрибутами класса.

```
class Vector:
    MIN_CORD = 0;
    MAX_CORD = 100;

    @classmethod
    def validate(cls, arg):
        return cls.MIN_CORD <= arg <= cls.MAX_CORD

print(Vector.validate(5))

True
```

`cls` - ссылка на текущий класс.

Метод класса можно вызвать через сам класс. 

Реализуем проверку, через метод класса:

```
class Vector:
    MIN_CORD = 0;
    MAX_CORD = 100;

    @classmethod
    def validate(cls, arg):
        return cls.MIN_CORD <= arg <= cls.MAX_CORD

    def __init__(self, x, y):
        self.x = self.y = 0
        if self.validate(x) and self.validate(y):
            self.x = x
            self.y = y

    def get_cords(self):
        return self.x, self.y
    

v = Vector(1, 200)
res = v.get_cords()
print(res)

(0, 0)
```

`@staticmethod` - методы, которые не имеют доступа к атрибутам класса и атрибутам экземпляров класса.

# Инкапсуляция # [&#8593;](#навигация)

Инкапсуляция - механизм ограничения к данным метода из вне. Если мы хотим ограничить прямой доступ к локальным свойствам экземпляров класса, то следует помечать их закрытми.

`atribute` - публичное свойство. Public.

```
class Point:
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y
        print(pt.x, pt.y)

1 2
```

`_atribute` - служит для обращения внутри класса и во всех дочерних классах. Protected.

```
class Point:
    def __init__(self, x = 0, y = 0):
        self._x = x
        self._y = y

1 2
```

В python `_` указывает на то что это внутренняя служебная переменная и используется лишь для того, чтобы предостеречь программиста от использования свойства вне класса.

`__atribute` - служит только для обращения внутри класса. Private. Если попытаться обратится к свойствам вне класса напрямую - получим ошибку. Необходимо использовать дополнительные методы:

```
class Point:
    def __init__(self, x = 0, y = 0):
        self.__x = x
        self.__y = y

    def set_coord(self, x, y):
        self.__x = x
        self.__y = y

    def get_coord(self):
        return self.__x, self.__y

pt = Point()

pt.set_coord(10,20)

print(pt.get_coord())
```

Метод класса set_coord - называется сэттер.

Метод класса get_coord - называется геттер.

Сеттер и геттер - интерфейсные методы. Служат для передачи значений между приватными атрибутами и проверки их корректности.

Реализуем проверку, что принимаемые x и y - числа. И добавим приватный метод для проверки корректности введенных координат `__check_value`

```
class Point:
    def __init__(self, x = 0, y = 0):
        self.__x = self.__y = 0
        if self.__check_value(x) and self.__check_value(y):
            self.__x = x
            self.__y = y

    @classmethod
    def __check_value(cls, x):
        return type(x) in (int, float)


    def set_coord(self, x, y):
        if self.__check_value(x) and self.__check_value(y):
            self.__x = x
            self.__y = y
        else:
            raise ValueError("expecting number")
        
    def get_coord(self):
        return self.__x, self.__y

pt = Point()
pt.set_coord(10, 20)

print(pt.get_coord())
```



